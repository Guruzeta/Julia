######### Model/simulation parameters
tğ‘=1 #phonon bandwidth
tâ‚‘=3 #electron bandwidth= = Ïƒ
a1=1  #lattice constant
Î»ğ‘= 1 #systembath coupling
Tâ‚‘=1.0 # electron temperature
Tğ‘=0.5 # phonon temperature
Î¼ = -1  # chemical potential of the electron


#time-simulation parameters
h= 0.1 #the time spacing
Time_max = 50 #the net time
Nğ‘¡= Int64(Time_max/h) #


#phonon volume parameters
sitenum = 6 #gives the no. of sites in the lattice
a2=2*Ï€*(1/(sitenum*a1)) #reciprocal space lattice constant
V_ph = collect(-0.5*sitenum*a2:a2:0.5*a2*(sitenum+1))
filter!(e->e!=0,V_ph) # not taking k=0 mode currently


#%%

Phonon definitions

### Disperion relation
function Ï‰ğ‘(k)
    return tğ‘*abs(sin(k*a1))
end
Ï‰ğ‘(10)

### Definition of Bare D_0, Dzerobar, and D_zero_K
function Dâ‚€á´¿(k,t1,t2)
    if t1>t2
        return (-(1)*sin(Ï‰ğ‘(k)*(t1-t2)*h))/(Ï‰ğ‘(k))     # the equal to case shall give 0
    else
        return 0
    end
end

Dâ‚€á´¿(10,2,1)
-sin(Ï‰ğ‘(10)*h)/Ï‰ğ‘(10)


function DÌ„â‚€á´¿(k,t1,t2)
    if t1>=t2                            ### What does DÌ„ do at equal times? produce 1? What if it rigorously doesn't hold?
        return (-1*cos(Ï‰ğ‘(k)*(t1-t2)*h))
    else
        return 0
    end                     #remember this is only true if t1>t2
end

DÌ„â‚€á´¿(10,1,1)
cos(Ï‰ğ‘(10)*h)


function Dâ‚€á´·(k,t,t1,Tphonon)
    a= (-im)*(cos(Ï‰ğ‘(k)*(t-t1)*h) * coth(Ï‰ğ‘(k)*0.5/(Tphonon)) )* (1/Ï‰ğ‘(k))
    return a
end

Dâ‚€á´·(10,2,1,1)

function DÌ„â‚€á´·(k,t,t1,Tphonon)
    return im*sin(Ï‰ğ‘(k)*(t-t1)*h)*coth(Ï‰ğ‘(k)*0.5/(Tphonon))
end

DÌ„â‚€á´·(1,2,1,1)

#%%
Electron Definitions

function Ïµâ‚‘(k)
    return tâ‚‘*(1-cos(k*a1))
end


function Gâ‚€á´¿(k,t1,t2)
    if t1>=t2
        return -im*exp(-im*Ïµâ‚‘(k)*(t1-t2)*h)
    else
        return 0
    end
end

Gâ‚€á´¿(10,1e4,1e4) #prints 0 for t1<t2

function Gâ‚€á´·(k,t1,t2,Telectron,Î¼)
    return -im*tanh((Ïµâ‚‘(k)-Î¼)/(2*Telectron))*exp(-im*Ïµ(k)*(t1-t2)*h)
end

#%%
Matrix definitions: making Array of arrays : each inner array is 2dim with currently undefine size, the outer array is 1d and holds
total k points+ 10 elements

Dá´¿matrix = Array{Array{ComplexF64,2},1}(undef,length(V_ph)+10)

DÌ„á´¿matrix = Array{Array{ComplexF64,2},1}(undef,length(V_ph)+10)

Dá´·matrix = Array{Array{ComplexF64,2},1}(undef,length(V_ph)+10)

DÌ„á´·matrix = Array{Array{ComplexF64,2},1}(undef,length(V_ph)+10)

Gá´¿matrix = Array{Array{ComplexF64,2},1}(undef,length(V_ph)+10)

Gá´·matrix = Array{Array{ComplexF64,2},1}(undef,length(V_ph)+10)

Î£ğ‘á´¿= Array{Array{ComplexF64,2},1}(undef,length(V_ph)+10)

Î£ğ‘á´· = Array{Array{ComplexF64,2},1}(undef,length(V_ph)+10)

Î£â‚‘á´¿ = Array{Array{ComplexF64,2},1}(undef,length(V_ph)+10)

Î£â‚‘á´· = Array{Array{ComplexF64,2},1}(undef,length(V_ph)+10)


for i=1:length(V_ph)+10
    Dá´¿matrix[i] = Array{ComplexF64,2}(undef,Nğ‘¡+5,Nğ‘¡+5)
    DÌ„á´¿matrix[i] = Array{ComplexF64,2}(undef,Nğ‘¡+5,Nğ‘¡+5)
    Dá´·matrix[i] = Array{ComplexF64,2}(undef,Nğ‘¡+5,Nğ‘¡+5)
    DÌ„á´·matrix[i] = Array{ComplexF64,2}(undef,Nğ‘¡+5,Nğ‘¡+5)
    Gá´¿matrix[i] = Array{ComplexF64,2}(undef,Nğ‘¡+5,Nğ‘¡+5)
    Gá´·matrix[i] = Array{ComplexF64,2}(undef,Nğ‘¡+5,Nğ‘¡+5)
    Î£ğ‘á´¿[i] = Array{ComplexF64,2}(undef,Nğ‘¡+5,Nğ‘¡+5)
    Î£ğ‘á´·[i] = Array{ComplexF64,2}(undef,Nğ‘¡+5,Nğ‘¡+5)
    Î£â‚‘á´¿[i] = Array{ComplexF64,2}(undef,Nğ‘¡+5,Nğ‘¡+5)
    Î£â‚‘á´·[i] = Array{ComplexF64,2}(undef,Nğ‘¡+5,Nğ‘¡+5)
end


Dá´¿matrix[10][1,1]


#%%
#Initialization

for k =1:length(V_ph)
    for i=1:Nğ‘¡
        Dá´¿matrix[k][i,i]=0 #exactly 0
        DÌ„á´¿matrix[k][i,i]=-1 #exactly 1
        Dá´·matrix[k][i,i] =1                   ### Why am I initializing the DK?
        Gá´¿matrix[k][i,i] = -im           ## Gr(t,t)â‰‚Ì¸0
        Gá´·matrix[k][i,i] = Gâ‚€á´·(k,t,t,Tâ‚‘,Î¼)      ### Why am I even initializing this? Aren't we supposed to get this from the code?

        Dá´¿matrix[k][i+1,i] = Dâ‚€á´¿(k,i+1,i) #only 2,1 or all i+1,i???
        DÌ„á´¿matrix[k] [i+1,i] = DÌ„â‚€á´¿(k,+i,i)
        Î£ğ‘á´¿[k][i+1,i]
        Î£ğ‘á´·
    end
    println(k)
end

Î£ğ‘á´¿[k][2,1]=??????????

# Definitions of convolutions for phonons

function F(k,tâ‚,tâ‚‚)
    if tâ‚>tâ‚‚
        return sum(t->Î£ğ‘á´¿[k][tâ‚,t]*Dá´¿matrix[k][t,tâ‚‚]*h, collect(tâ‚‚:tâ‚))
    elseif tâ‚==tâ‚‚
        return 0
    else
        return "You're convoluting in the opposite direction. Possible error at RR conv"
    end
end


F(3,9,10)

function RK(k,t1,t2) #âˆ«â‚€áµ— Î£ğ‘á´¿â‹…Dá´·
    if t1>1
        return sum(t->Î£ğ‘á´¿[k][t1,t]*Dá´·matrix[k][t,t2]*h, collect(1:t1))
    else
        return 0
    end
end

RK(2,2,3)

function KA(k,t1,t2) #âˆ«â‚€â‹…Dá´¿
    if t2>1
        return sum(t->Î£ğ‘á´·[k][t1,t]*Dá´¿matrix[k][t2,t] * h, collect(1:t2)) ## Dá´¬ is just transpose of Dá´¿
    else
        return 0
    end
end
KA(2,3,2)

###### Equivalent definitions of convolutions for electrons ###########

function Fâ‚‘(k,tâ‚,tâ‚‚)
    if tâ‚>tâ‚‚
        return sum(t->Î£â‚‘á´¿[k][tâ‚,t]*Gá´¿matrix[k][t,tâ‚‚]*h, collect(tâ‚‚:tâ‚))
    elseif tâ‚==tâ‚‚
        return 0
    else
        return "You're convoluting in the opposite direction. Possible error at RR/electron conv"
    end
end

function RKâ‚‘(k,t1,t2) #âˆ«â‚€áµ— Î£â‚‘á´¿â‹…Dá´·
    if t1>1
        return sum(t->Î£â‚‘á´¿[k][t1,t]*Gá´·matrix[k][t,t2]*h, collect(1:t1))
    else
        return 0
    end
end


RK(2,2,3)

function KAâ‚‘(k,t1,t2) #âˆ«â‚€â‹…Dá´¿
    if t2>1
        return sum(t->Î£â‚‘á´·[k][t1,t]*conj(Gá´¿matrix[k][t2,t] )*h, collect(1:t2))
    else
        return 0
    end
end

function sumBZ1d(k,p) # returns the index of element in the BZ array that reflects the physical sum of two input indices, taking the periodic behaviour into account
    if k==Ï€/a1 && p==Ï€/a1
        return \
    end
end
length(V_ph)

indexin(Ï€/a1,V_ph)[1]

#%%

#Actual for loop
for i=2:Nğ‘¡   ### The diagonal value #should probably start from 2


    #Update DR
    for k=1:length(V_ph)
        for j=1:i

            if j<i
                DÌ„á´¿matrix[k][i,j] = Ï‰ğ‘(k)^2 * Dâ‚€á´¿(k,i,i-1) * Dá´¿matrix[k][i-1,j] - DÌ„â‚€á´¿(k,i,i-1) * DÌ„á´¿matrix[k][i-1,j] + (h/2)*( DÌ„â‚€á´¿(k,i,i)* F(k,i,j) + DÌ„â‚€á´¿(k,i,i-1) * F(k,i-1,j) )
            end
            Dá´¿matrix[k][i+1,j] = DÌ„â‚€á´¿(k,i+1,i) * Dá´¿matrix[k][i,j] + Dâ‚€á´¿(k,i+1,i) * DÌ„á´¿matrix[k][i,j] + (h/2)*Dâ‚€á´¿(k,i+1,i)*F(k,i,j)
        end
    end

     #Update DK
     for k = 1:length(V_ph)
         for j=1:i

             DÌ„á´·matrix[k][i,j] = Ï‰ğ‘(k)^2 * Dâ‚€á´¿(k,i,i-1) * Dá´·matrix[k][i-1,j] - DÌ„â‚€á´¿(k,i,i-1) * DÌ„á´·matrix[k][i-1,j] + (h/2)*(  DÌ„â‚€á´¿(k,i,i)* RK(k,i,j) + DÌ„â‚€á´¿(k,i,i-1)* RK(k,i-1,j) + DÌ„â‚€á´¿(k,i,i)* KA(k,i,j) + DÌ„â‚€á´¿(k,i,i-1)* KA(k,i-1,j) )
             Dá´·matrix[k][i+1][j] = DÌ„â‚€á´¿(k,i+1,i) * Dá´·matrix[k][i,j] + Dâ‚€á´¿(k,i+1,i) * DÌ„á´·matrix[k][i,j] + (h/2)*( Dâ‚€á´¿(k,i+1,i)* RK(k,i,j) + Dâ‚€á´¿(k,i+1,i)* KA(k,i,j) )
             Dá´·matrix[k][j,i+1] = -conj(Dá´·matrix[k][i+1,j])
             if j!=i
                DÌ„á´·matrix[k][j,i] = +conj(DÌ„á´·matrix[k][i,j])#what abt i,i entry? If Dk is imaginary, then it will just flip sign here.....? This term is to take care of that...Not sure
             end
         end
     end

    # Update GR, GK
    for k = 1 : length(V_ph)
        for j=1:i
            Gá´¿matrix[k][i+1,j] = im*Gâ‚€á´¿(k,i+1,i)*Gá´¿matrix[k][i,j] + (h/2)* Gâ‚€á´¿(k,i+1,i)*(Fâ‚‘(k,i,j))
            Gá´·matrix[k][i+1,j] = im*Gâ‚€á´¿(k,i+1,i)*Gá´·matrix[k][i,j]+ (h/2)*Gâ‚€á´¿(k,i+1,i)* (RKâ‚‘(k,i,j) + KAâ‚‘(k,i,j))
            Gá´·matrix[k][j,i+1] = - conj(Gá´·matrix[k][i+1,j]) # iGá´· is hermitian  âŸ¹ iGá´·(1,2) = conj((iGá´·(2,1)) âŸ¹ Gá´·(1,2) = - conj(Gá´·(2,1))
        end
    end

for j=1:i
    # Extract Phonon self energy Î£ğ‘á´·,Î£ğ‘á´¿ in the n+1,n+1 block (use in Dr calculation in next loop)
    # Î£ğ‘á´¿ update
    for j=1:i
        for k=1:length(V_ph)
            sum=0
            for p=1:length(V_ph)
                if V_ph(k)+V_ph(p)>Ï€/a
                    if k==Ï€/a && p==Ï€/a
                        momentum = Ï€/a
                    else
                        momentum = indexin(V_ph(k)+V_ph(p)-2*Ï€/a,V_ph)
                    end
                        Î£ğ‘á´¿[k][i+1,j] = -(Î»ğ‘^2)/2*()
                    momentum=nothing

                elseif  V_ph(k)+V_ph(p)<-Ï€/a
                    momentum = indexin(V_ph(k)+V_ph(p)+2*Ï€/a,V_ph)

                else
                    momentum =

                    momentum=nothing

                end


            end
        end
    end


    #Now extract self energies Î£â‚‘á´¿,Î£â‚‘á´· in the n+1,n+1 block (shall be used for calculation of GR in n+2,n+2 loop i.e. next big loop's GR,GK update since you're dropping the self consistent term)

    #Update GK(t+Ïµ,t+Ïµ) i.e GK(i+1,i+1) here  - needs Î£â‚‘á´¿ on the i+1 block edges  i.e.

    #Update DK(t+Ïµ,t+Ïµ) here, DÌ„(i,i) block is calculated already


end

1<2+3<5

indexin(7,b)[1]

2+3>Ï€

real(2+3*im)

mod(-1,2)-1
Î´=2*Ï€/6
2.09-2*

#if it isn't <-Ï€ or >Ï€, then keep it as it is. If it's more, then add or subtract 2Ï€

1+2~4
1+3~5
1+4~2
1+5~3
1+6
2+3~1 or 6

Î»ğ‘^2/2


V_ph

i = findall(x->x==5,b)


a=collect(1:10)
b=collect(4:10)
a[5]
f(t) = sum(t->a[t]*b[t], collect(1:Int64(t)))

f(5)


c = collect(1:10)


g(i,j) = if sum(t-> a[i]*c[t]*b[j], collect(j:i))*(i>j)
mod()
